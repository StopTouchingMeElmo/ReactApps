import React, { Component } from 'react';
import cl from 'classnames';
import s from './Card.module.scss';

//КОМПОНЕНТЫ-КЛАССЫ.
//метод render не принимает значения props
//в классе все props - это поля этого класса
//чтобы к ним обратиться нужно написать this.props
//это дает возможность доступка к пропсам из любого метода нашего класса, а не только из render, если бы туда передавались пропсы
//========================================================================================

//Способы передать функцию в обработчик СОБЫТИЙ:
//Полный список поддерживаемых СОБЫТИЙ https://ru.reactjs.org/docs/events.html
//(1)Когда мы передаем функцию handlerCardCkick в обработчик onClick, она не сохраняет связи с объектом, в котором была создана,
//т.о. при ее вызове пропадает this, поэтому нашу функцию необходимо обернуть в анонимную стрелочную функцию.
//т.к. стрелочная функция лексически привязана к месту вызова. В нашем случае к методу render.

//(2)Или сразу объявлять метод handlerCardCkick в виде стрелочной функции
//(3)Через метод handlerCardCkick.bind(this), но этот способ будет при каждом вызове создавать новую функцию, в которую будет оборачивать
//наш метод. Такая практика считается нежелательной.

//Вывод: желательно использовать стрелочные функции внутри классов.
//==========================================================================================

// State - состояние классового компонента.
// В наших классовых компонентах мы можем хранить их внутреннее состояние.
// Это состояние инкапсулировано от всех и у каждого класса оно собственное.
// Каждый компонент может хранить в себе ряд переменных, изменять их и показывать результат.

// Нажимаем на клик, который вызывает функцию handlerCardCkick
// handlerCardCkick вызывает функцию setState
// setState сообщает реакту, что состояние компонента только что поменялось
// Реакт перерисовывает компонент. Вызывет функцию render.
// render рисует компонент с новым значением state

// Классический способ добавления/удаления класса в атрибут тэга(*)
// Способ с помощью библиотеки https://www.npmjs.com/package/classnames (**)

class Card extends React.Component {
    /*(1) handlerCardCkick(){
        console.log('Translated', this.props.rus)
    } 
    onClick={()=>this.handlerCardCkick()}*/

    state = {
        done: false
    }
    
   
    handlerCardCkick = () => {
       this.state.done? this.setState({
            done: false
        }):this.setState({
            done: true
        })

    }//(2)
    
    render(){
        const { eng, rus, id} = this.props
        const { done} = this.state

        //let classList = [s.card]//(*)
        //done?classList.push(s.done):classList = [s.card]

        return(
            <div 
            //className={classList.join(' ')}//(*)
            className={ cl(s.card, {[s.done]:done})}//(**)
            onClick={this.handlerCardCkick}
            >
                <div className={s.cardInner}>
                    <div className={s.cardFront}>
                        { eng }
                    </div>
                    <div className={s.cardBack}>
                        { rus }
                    </div>
                </div>
                
            </div>
        )
    }
}

export default Card;

//=======================================================================================
//Функциональные компоненты.
/* const Card = ({eng, rus}) => {
    return (
            <div className={s.card}>
                <div className={s.cardInner}>
                    <div className={s.cardFront}>
                        { eng }
                    </div>
                    <div className={s.cardBack}>
                        { rus }
                    </div>
                </div>
                
            </div>
        );
} */

/*
Раньше фк не делали ничего, кроме отображения реакт элементов.
Сама функция выглядит компактно и удобно, легко тестируется.
Имя функции,
котора в аргументах имеет пропс,
которые мы можем отобразить,
и дальше возвращать реакт элемент.

Но у функций был ряд ограничений (до появление хуков).
У функции нет внутреннего состояния.
Мы можем только получать к-то значения и их показывать.
Например:
const Card = ({eng, rus}) => {
    let count = 1
    setInterval(() => {
        count++
        console.log('New value:', count)
    }, 1000);
    return (
            <div className={s.card}>
                <div className={s.cardInner}>
                    <div className={s.cardFront}>
                        { eng }
Функция передаст только первое значение (let count = 1),
после чего будет исполнена. Дальнейшие значения сетинтервала не будут переданы.

Для этих целей в Реакте есть Компоненты-Классы.
У них есть собственное изменяемое внутреннее состояние.*/